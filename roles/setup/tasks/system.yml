# docker cli settings
- name: Create Docker settings directory
  file:
    path: .docker
    state: directory

- name: Create Docker settings file
  copy:
    dest: ".docker/config.json"
    content: |
      {}
- name: "Enable Docker experimental cli (docker manifest)"
  lineinfile:
    path: .docker/config.json
    insertafter: "^{"
    line: '	"experimental": "enabled",'

# # Add Kubernetes internal DNS server to host -> needed for glusterfs client to resolve nodes
# - name: Check if old resolv.conf is being used - /etc/resolvconf/resolv.conf.d/tail
#   stat:
#     path: "/etc/resolvconf/resolv.conf.d/tail"
#   register: isOldResolv
# #Handle legacy resolv.conf
# - name: "Add Kubernetes internal DNS to host resolv"
#   blockinfile:
#     path: /etc/resolvconf/resolv.conf.d/head
#     block: |
#       options rotate
#       options timeout:1
#       nameserver 10.96.0.10
#   register: result
#   when: isOldResolv.stat.exists
# - name: Restart resolvconf service
#   systemd:
#     name: resolvconf
#     state: restarted
#     enabled: yes
#     daemon_reload: yes
#   when: "isOldResolv.stat.exists and result | changed"
# #Handle systemd handling DNS
# - name: "Create fix resolv.conf"
#   copy:
#     dest: /etc/resolv.conf
#     content: |
#       # This file was created by ansible
#       nameserver 10.96.0.10
#       nameserver 127.0.0.53
#       search fritz.box
#   when: "isOldResolv.stat.exists == False"


# Logrotate
- name: "Limit max log files to 1 MB each"
  lineinfile:
    path: /etc/logrotate.conf
    insertbefore: BOF
    line: maxsize 1M

- name: "configure cron to run logrotate each 30 minutes"
  copy:
    dest: /etc/cron.d/extralogrotate
    content: |
      */30 * * * * root /etc/cron.daily/logrotate

  register: result

- name: Restart cron service
  systemd:
    name: cron
    state: restarted
    enabled: yes
    daemon_reload: yes
  when: result | changed

# Set hostname
- name: Set hostname
  hostname: name="{{ name }}"
  register: set_hostname

- name: Restart hostname
  shell: "hostnamectl set-hostname {{ name }}"
  when: set_hostname.changed

# Set timezone
- name: "Write timezone file with {{ timezone }}"
  copy:
    content: "{{ timezone }}"
    dest: /etc/timezone
  register: result

- name: Enable new timezone
  shell: "timedatectl set-timezone {{ timezone }}"
  when: result | changed

# Disable Swap
- name: swap - remove current swaps from fstab
  lineinfile:
    dest: /etc/fstab
    regexp: '^/[\S]+\s+none\s+swap '
    state: absent

- name: swap - disable swap
  shell: "cat /proc/swaps|tail -n +2 && swapoff --all"
  register: result
  changed_when: result.stdout_lines | length

- name: swap - disable swap on Raspberry Pi
  shell: "which dphys-swapfile || dphys-swapfile swapoff && dphys-swapfile uninstall && systemctl disable dphys-swapfile"
  register: result
  when: result|changed
  changed_when: result.stdout_lines | length

- name: "Enable memory cgroup in Raspberry PIs"
  shell: test ! -e cgroup_enable=memory || grep -v "cgroup_enable=memory" /boot/cmdline.txt && echo -n "cgroup_enable=memory cgroup_memory=1 $(cat /boot/cmdline.txt)">/boot/cmdline.txt
  register: result
  changed_when: result.stdout_lines | length

- name: Reboot immediately if there was a change.
  shell: "sleep 5 && reboot"
  async: 1
  poll: 0
  when: result | changed

- name: Wait for the reboot to complete if there was a change.
  wait_for_connection:
    connect_timeout: 20
    sleep: 5
    delay: 5
    timeout: 300
  when: result | changed

# # disable local dns server
# - name: Comment out the dnsmask
#   replace:
#     dest: /etc/NetworkManager/NetworkManager.conf
#     regexp: '^dns=dnsmasq'
#     replace: '#dns=dnsmasq'
#   register: result
#
# - name: Restart Network Manager
#   systemd:
#     name: network-manager
#     state: restarted
#     enabled: yes
#     daemon_reload: yes
#   when: result | changed
